# Cursor Rules для Flutter

## Архитектура и структура проекта

### Организация файлов
- Чёткое разделение на директории:
  - `lib/screens/` - экраны приложения
  - `lib/widgets/` - переиспользуемые виджеты
  - `lib/services/` - бизнес-логика и API-сервисы
  - `lib/models/` - модели данных
  - `lib/utils/` - утилиты и хелперы
  - `lib/constants/` - константы
- Каждый файл должен иметь понятное название, отражающее его назначение
- Используй snake_case для имен файлов (например: `user_profile_screen.dart`, `api_service.dart`)
- Один класс/виджет на один файл (кроме связанных утилит)
- Каждая папка (screens, widgets, services, models, utils, constants) должна содержать файл `index.dart` для экспорта всех публичных элементов
- Все экспорты из папки должны быть в `index.dart` этой папки
- Импорт из других папок должен происходить только через `index.dart` соответствующей папки
- Пример: `import 'package:physics_ball/screens/index.dart';` вместо `import 'package:physics_ball/screens/user_profile_screen.dart';`

### Читаемость кода
- Используй понятные имена переменных, функций и классов
- Избегай сокращений, если они не общепринятые
- Функции должны быть короткими и выполнять одну задачу (принцип Single Responsibility)
- Используй const конструкторы везде, где возможно
- Группируй связанные импорты: сначала dart, потом flutter, потом пакеты, потом локальные

### Избегай дублирования
- Выноси повторяющуюся логику в отдельные функции/классы
- Используй переиспользуемые виджеты вместо копирования кода
- Создавай базовые классы для общей функциональности
- Используй mixins для переиспользуемого поведения

## Логирование и обработка ошибок

### Обработка ошибок
- Все API-запросы должны быть обёрнуты в try-catch блоки
- Используй Result/Either паттерн для обработки ошибок, где это уместно
- Всегда обрабатывай ошибки сети, таймауты и ошибки парсинга
- Предоставляй пользователю понятные сообщения об ошибках
- Не показывай технические детали ошибок пользователю

### Логирование
- Используй `debugPrint` для отладочной информации в разработке
- Логируй важные действия: начало/завершение API-запросов, навигацию, критичные пользовательские действия
- Логируй ошибки с контекстом (метод, параметры запроса без чувствительных данных)
- Используй уровни логирования (debug, info, warning, error)
- В production режиме отключай debug-логи

### Безопасность
- НИКОГДА не логируй:
  - API ключи и токены
  - Пароли и PIN-коды
  - Персональные данные пользователей (полные номера телефонов, адреса, email)
  - Данные банковских карт
- Маскируй чувствительные данные в логах (например, показывай только последние 4 цифры)
- Не храни секреты в коде, используй переменные окружения или secure storage

## Производительность и стабильность

### Оптимизация рендеринга
- Минимизируй перерисовки: используй `const` виджеты везде, где возможно
- Используй `const` конструкторы для неизменяемых виджетов
- Разбивай большие виджеты на меньшие для оптимизации перестроек
- Используй `RepaintBoundary` для изоляции дорогих виджетов
- Избегай создания виджетов в build методах - выноси их в поля класса
- Используй `ListView.builder` вместо `ListView` для длинных списков
- Используй `keys` для виджетов в списках, когда порядок может меняться

### Оптимизация состояния
- Используй `setState` только когда необходимо
- Рассмотри использование `ValueNotifier`, `ChangeNotifier` или state management (Provider, Riverpod, Bloc) для сложного состояния
- Избегай ненужных перестроек через правильное использование `const` и мемоизацию
- Используй `AutomaticKeepAliveClientMixin` для сохранения состояния виджетов в списках

### Асинхронные операции
- Всегда обрабатывай асинхронные операции с обработкой ошибок
- Используй `FutureBuilder` или `StreamBuilder` для асинхронных данных
- Отменяй запросы при dispose виджета (используй `CancelToken` для dio или отмену Future)
- Используй debounce/throttle для частых операций (поиск, валидация)

### Размеры экранов
- Используй `MediaQuery` для адаптации под разные размеры экранов
- Используй `LayoutBuilder` для адаптивных макетов
- Тестируй на разных размерах экранов (phone, tablet)
- Используй `SafeArea` для избежания перекрытия системными элементами
- Используй `Flexible` и `Expanded` вместо фиксированных размеров, где возможно

### Стабильность
- Приложение должно запускаться без ошибок
- Обрабатывай все возможные null значения (используй null-safety)
- Проверяй наличие данных перед использованием
- Используй валидацию входных данных
- Тестируй edge cases (пустые списки, null значения, ошибки сети)

### Зависимости
- Не добавляй лишние зависимости без необходимости
- Регулярно обновляй зависимости для безопасности
- Проверяй размер пакетов перед добавлением
- Используй только необходимые части больших библиотек

## Общие принципы

- Следуй принципам SOLID
- Придерживайся принципа KISS (Keep It Simple, Stupid)
- Пиши самодокументируемый код
- Рефакторь код при необходимости
- Используй анализатор кода (flutter analyze) перед коммитом
- Следуй Dart style guide и Flutter best practices
